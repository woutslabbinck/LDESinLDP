<pre class='metadata'>
Title: Writing Linked Data Event Streams in LDP Basic Containers
Shortname: LDESinLDP
Level: 1
Status: LD
Group: TREE community group
<!-- URL: https://w3id.org/ldes/specification -->
Markup Shorthands: markdown yes
Editor: Pieter Colpaert, https://pietercolpaert.be
Editor: Wout Slabbinck
<!-- Repository: https://github.com/SEMICeu/LinkedDataEventStreams -->
Abstract: Writing to a time-based fragmented Linked Data Event Stream that is stored on a Linked Data Platform.
</pre>

<pre class=biblio> 
{"ldes": {
      "href":"https://w3id.org/ldes/specification",
      		"authors": [
			"Pieter Colpaert"
		],
		"title": "Linked Data Event Streams",
		"status": "LS"
	},
"tree":{
		"href":"https://w3id.org/tree/specification",
      		"authors": [
			"Pieter Colpaert"
		],
		"title":"The TREE hypermedia specification",
		"status": "LS"
	},   
"shex": {
		"href": "http://shex.io/shex-semantics/index.html",
		"title": "Shape Expressions Language 2.1",
		"authors": [
			"Eric Prud'hommeaux",
			"Iovka Boneva",
			"Jose Emilio Labra Gayo",
			"Gregg Kellogg"
		]
    }
}
</pre>
Introduction {#introduction}
=====================

We coin the term **LDES in LDP** to describe a time-based fragmented  [[!LDES]] that is stored on a Linked Data Platform [[!LDP]].
Which allows to interact with LDESs using the LDP API.


LDES in LDP {#ldesinldp}
=====================
<figure id="architecture">
<img src="./img/LDESinLDP_Architecture.png">
<figcaption>Architecture of a Linked Data Event Stream in an LDP Container</figcaption>
</figure>
<!--<!---->
<!--\subsubsection{Architecture}-->
<!--In \cref{fig:ldes-in-ldp-architecture} the LDP (here a Solid Community Server (CSS) \cite{noauthor_community_2022}), the LDES in LDP and the Basic LDES Orchestrator are merged together as the complete architecture. This overview shows clearly the structure of the LDES. The base container contains one or more \textit{fragments} and the \textit{root} of the LDES, a \textit{metadata} resource and the \textit{shape}.--> 
<!--The \textit{metadata} resource indicates the fragment that is writable.-->
<!--The \textit{root} resource contains the Event Stream and the view with relations to all LDP containers (fragments) in \textit{\{container\}}.--> 
<!--Each fragment contains an \textit{ACL resource}, a \textit{metadata resource} and several other LDP Resources which are the members of the Event Stream.--> 
<!--In the metadata, a constraint is placed to indicate that all members conform to the \textit{shape}.--> 

<!--Finally, the Orchestrator is responsible for creating new fragments when the current one is deemed full.-->

<!--\begin{figure}-->
<!--\centering-->
<!--\includegraphics[width=.6\textwidth]{img/LDES_Write-Architecture.pdf}-->
<!--\caption{Architecture of the LDES in LDP} \label{fig:ldes-in-ldp-architecture}-->
<!--\end{figure}-->
<!---->

**LDES in LDP** consists of the structure and protocol to create, update and interpret a continously growing time-based fragmented [[!LDES]].

The structure is visualized in the <a href="#architecture">figure</a> above and can be summarized in the following components:

* The `ldp:BasicContainer`, identifyable with an [[!URL]], which is the base of the **LDES in LDP**
* The **root** of the [[!LDES]]
* The fragments
* (Optionally) The shape
* (Optionally) Access control List Resources



An **LDES in LDP** is initialized in a data pod as an `ldp:BasicContainer` which contains the root of the LDES, a first fragment and extra metadata about this container. In the subsections, more details about this metadata will be given.

The **root** resource contains metadata about the **Event Stream** and its **view** using the [[!TREE]] hypermedia and [[!LDES]] vocabulary.
The **view** consist of several `tree:relation`s which contain information about the **fragments** of the **Event Stream**.

Each **Fragment** of an **LDES in LDP** is an `ldp:BasicContainer`. The LDP Resources present in a fragment (indicated by `ldp:contains`), are the members of the **Event Stream**.

Below is an example of a <a href="#root">root</a> <!--,where `http://example.org/{container}/` is the base URI of the LDES in LDP-->.
It consists of one `tree:relation`, where its class and properties indicate that all members, which were created after December the 15th, can be found by traversing to node `http://example.org/{container}/1639526400000/`.

<div class="example" highlight="turtle" id="root"> 
```turtle
@prefix : <http://example.org/{container}/root.ttl#> .
<http://example.org/{container}/root.ttl> rdf:type tree:Node ;
    tree:relation [ 
        a tree:GreaterThanOrEqualToRelation ;
        tree:node <http://example.org/{container}/1639526400000/> ;
        tree:path dct:modified ;
        tree:value "2021-12-15T00:00:00.000Z"^^xsd:dateTime
        ] .

:Collection a <https://w3id.org/ldes#EventStream> ;
    tree:shape <http://example.org/{container}/shape> ;
    tree:view <http://example.org/{container}/root.ttl>

```
</div>

## Adding Resources ## {#adding-resources}

The method for adding a resource remains the same as for a normal LDP Resource creation: with an HTTP POST request. However, an application that adds a member to the Event Stream must know where to write to. 
To indicate the write location, a property already defined in the LDP specification is reused: the LDP Inbox (`ldp:inbox`, originated from the [[!LDN]] specification).

Thus a triple of the form `<baseContainer> ldp:inbox <locationURI>.` is added to the metadata of the base container.
This location URI is retrieved via the Link Header as the link value to the relation `ldp:inbox` when sending a GET or HEAD HTTP request. 

Finally, a member can be added to the LDES with an HTTP POST request to the obtained location URI.

The following <a href="#meta-inbox">example</a> shows the inbox triple. When performing a HEAD <a href="#head-request">request</a> to the base URL (`http://example.org/{container}/`), the Link Header with the write location (`http://example.org/{container}/1639526400000/`) is present in the corresponding <a href="#head-response">response</a>.

<div class="example" highlight="turtle" id="meta-inbox"> 
```turtle
<http://example.org/{container}/> ldp:inbox <http://example.org/{container}/1639526400000/>.
```
</div>

<!--Below are examples of a HEAD <a href="#head-request">request</a> to the base URL and the corresponding <a href="#head-response">response</a> showing the Link Header.-->

<div class="example" highlight="HTTP" id="head-request">
```HTTP
HEAD /{container}/ HTTP/1.1
Host: http://example.org
```
</div>
<div class="example" highlight="HTTP" id="head-response">
```HTTP
HTTP/1.1 200
link: <http://example.org/{container}/1639526400000/>; rel="http://www.w3.org/ns/ldp#inbox"
```
</div>



## Improving Interoperability ## {#interoperability}

The `tree:shape` property of a [[!TREE]] Collection indicates the data model that all of its member conform to. This data model is called a **shape** and is expressed in a shape language like [[!SHACL]] or [[!SHEX]].

When it is known a priori that the LDES will only have members with a certain predefined data model, it is possible to initialise the LDES in LDP with a shape. 

To enforce shape validation executed by the LDP, the validator requires to know which shape resource to use.
Therefore, the constrained by property of LDP (`ldp:constrainedBy`) will be used to encode an URI to the shape resource in the metadata of each fragment container.

Since all requests to add data that does not conform to the shape will be rejected, the resulting Event Stream consists of members that all conform to the shape.


<div class="example" highlight="turtle" id="meta-inbox"> 
Example of the metadata a fragment of an LDES in LDP that is constrained by a shape.
```turtle
<http://example.org/{container}/1639526400000/> tree:shape <http://example.org/{container}/shape>.
```
</div>

Basic LDES Orchestrator {#orchestrator}
=====================

The **Basic LDES Orchestrator** is introduced to reduce overhead for the client and perform the operations that not any client is allowed to perform.

This Basic LDES Orchestrator has four roles:

* Creation of new LDP Container: when the current relation is deemed full, a new container is created with added metadata to indicate shape support
* Writable container indication: at the base container, update the metadata about the LDP Inbox
* Maintain the root of the LDES: add triples with TREE syntax to keep the view up to date
* Access control: when Solid is used, the Access Control List (ACL) files must be updated

## Create Containers 

Downloading a document on the internet takes time proportional to the location of the server versus the location of the client, the bandwidth and the size of the document. 
Designing LDES in LDP while minimizing that time, results in controlling the size of documents where possible: the container size.
When a container contains a large number of resources,  the serialization of the information of that container is large as well.
This results in a bottleneck for the performance as loading the container page takes longer. 

To overcome this bottleneck, every time the current container page is deemed full, a new, empty container is created.
Furthermore, when the LDES in LDP is initialised with a shape, metadata must be added to this container to further impose this constraint, see [](#interoperability).

## Writable Container Indication 

When a new container is created, the Inbox must be updated as well. 
Clients that want to add a member to the LDES can then find the container where they can write new resources, see [](#adding-resources).

It is the responsibility of the Orchestrator to update that triple in the metadata.

## Maintain the View 

The [[!TREE]] hypermedia specification states that a view of a collection must reach all its members. 
Therefore on each creation of a new container, which is a new fragment of the collection, the view must be updated. 
Thus a relation is added in the root by the Orchestrator for each new fragment.

## Update ACL Files 

In case a Solid pod is used as a back-end, ACL resources are responsible for making sure that it is impossible to add new resources to containers that are not indicated as writeable. 
With an ACL resource in place in the current fragment container, it is enforced that only new resources may be added there.
This is done by providing read (`acl:read`) and append (`acl:append`) rights in the ACL resource of that container.

Note: The orchestrator must have `acl:Control` for the base container and each fragment container to be able to update the ACL resources.

## Sequence Diagram

<!--Now that all the roles are elaborated, they are joined together in an arrangement to manage the growth of the LDES in LDP. -->
<a href="sequence_diagram">The figure below</a> shows the operations that the Orchestrator performs each time a new fragment is created for the case of a public LDES in LDP.

<figure id="sequence_diagram">
<img src="./img/LDES_Write-Orchestrator.png">
<figcaption>Sequence diagram of the Basic LDES Orchestrator for a public LDES in LDP</figcaption>
</figure>

Note: An implementation of the Basic LDES Orchestrator can be found on **npm**: [LDES Orchestrator](https://www.npmjs.com/package/@treecg/ldes-orchestrator)

Implementation {#implementation}
=====================


## Version-Aware Implementation

Note: Rewrite this, it should explain how to use LDES in LDP when clients understand the protocol

When an application knows how to append to an LDES in LDP, it may add updates of resources directly to the *feed*. 
As stated previously, this would also change the contents of the LDP Container because it is just a derived view of the *feed*.


## Version-Agnostic Implementation

With LDES in LDP it is possible to build up the history of a given resource using the Version Materializations of that resource, and synchronize and replicate this LDES with the use of LDES Action and LDES Client.
<!--\footnote{Version Materializations defined in the LDES specification \url{https://semiceu.github.io/LinkedDataEventStreams/\#version-materializations}}\footnote{\url{https://github.com/TREEcg/event-stream-client} \cite{van_lancker_publishing_2021}}.-->
Unfortunately, not all clients can understand LDES in LDP.

Therefore, a proposal is being presented that combines the simplicity to perform CRUD operations with RDF data on an LDP and the expressivity of an LDES in LDP. Here, the LDES in LDP is used as the source for the resources that are shown in the LDP.

### Architecture

<a href="#ldesasbase">The architecture figure</a> shows the structure when the LDP is combined with the LDES in LDP. The resources that are present in the `{container}` are a view derived from the LDES in *feed*, which is stored as an LDES in LDP. More specifically a view that only contains the latest version of a given member in the Event Stream.
Thus when a resource has multiple versions (e.g. due to it being edited) only the latest version will be shown in the LDP. However, the whole history of those resources can be retrieved from the *feed*.

<figure id="ldesasbase">
<img src="./img/Version_Materialized_View.png" />
<figcaption>Architecture when LDES is used as base in a version-agnostic approach</figcaption>
</figure>
With this proposal, reading from an LDES in LDP for clients who are not aware is thus solved. 
Though in order to use this feed as storage and let the LDP still appear as normal while creating, updating and deleting resources, additional modifications are required.

### Creating

An HTTP POST request is used to create a resource in an LDP. 
When a POST request is sent to an LDP Container three things happen: an identifier is created by the server for the created LDP Resource, the body of the request becomes the LDP Resource and metadata is added in the container to indicate that it contains the new resource.

For  Version-Agnostic implementations, the LDP behaviour for a POST is just the first step. The second step consists of combining the body of the request with two extra triples to indicate the version-specific representation. 
The newly composed body is then added to the *feed* LDES.

The first triple is to indicate the time of the creation of the Resource, the second triple is the reference to the identifier of the resource.
An example of those triples when the server chose `http://example.org/\{container\}/resource2` as identifier is shown in the <a href="#add-version-triples">example</a> below.

<div class="example" highlight="turtle" id="add-version-triples">
```turtle
@prefix : <http://example.org/{container}/> .

:feed/1639612800000/{uuid} dct:issued "2021-12-16T10:00:00.000Z"^^xsd:dateTime .
:feed/1639612800000/{uuid} dct:isVersionOf :resource2 .
```
</div>

Note: When a slug is provided in the Header of a POST request, a server can choose to use that slug as an identifier.

### Updating

Updating LDP Resources can be done in two ways. 
First, there is an HTTP PUT request which replaces the resource with the body that accompanies the request. 
The second option is using an HTTP PATCH request that uses a [[!SPARQL-UPDATE]]  query, where first the server applies the changes and then the result is stored as the updated resource.

An LDP with Version-Agnostic LDES in LDP  support stores those updates in the *feed* as the newest version. Thus when using PUT, the whole body of the request together with the version-specific triples are added to *feed*.
After applying the changes using a PATCH request, the resulting resource is accompanied with  the version-specific triples and appended to the *feed*.

### Deleting

An HTTP DELETE request to an identifier of a resource results in the removal of that resource and its corresponding metadata in the parent container. In the *feed* however, all the versions are not removed because of two reasons. 
The first one is that an LDES is immutable, meaning that members can not be edited once they are in an LDES.
The second reason is that the history of this resource would be removed as well.

Thus next to the LDP behaviour, an item consisting of three triples is added to the *feed* to indicate a resource has been removed. 
Two of those triples are the version-specific ones, the last one is just an indication that the resource has been removed from the LDP. 
For this last triple `<https://example.org/versionMemberURI> ldes:state ldes:removed .` is proposed.

Examples {#examples}
=====================

## Metadata notifications

At [https://tree.linkeddatafragments.org/announcements/](https://tree.linkeddatafragments.org/announcements/), a public, shape constrained LDES in LDP can be found which is used for publishing metadata of DCAT Application Profiles [[!VOCAB-DCAT-3]] about datasets or data services, or metadata of a TREE View.
As LDP, a Community Solid Server [[CSS](https://github.com/solid/community-server)] instance is used with shape support. 
On the server where the CSS resides, the Basic LDES Orchestrator runs.
The trigger for creating new containers is when the current fragment container contains 100 resources or more.

Note: The CSS with shape support can be found at [https://github.com/woutslabbinck/community-server](https://github.com/woutslabbinck/community-server) on branch feat/shape-support

Note: The Orchestrator uses the following package: [LDES Orchestrator](https://www.npmjs.com/package/@treecg/ldes-orchestrator)

Namespaces {#namespaces}
=====================

Commonly used namespace prefixes used in this specification:
```turtle
@prefix acl: 	<http://www.w3.org/ns/auth/acl#> .
@prefix dct: 	<http://purl.org/dc/terms/> .
@prefix ldes: 	<https://w3id.org/ldes#> .
@prefix ldp: 	<http://www.w3.org/ns/ldp#> .
@prefix rdf: 	<http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix tree: 	<https://w3id.org/tree#> .
@prefix xsd: 	<http://www.w3.org/2001/XMLSchema#> .
```